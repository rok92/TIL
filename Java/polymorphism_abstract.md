## 타입 변환과 다형성 / 객체 배열

#### 1. 다형성

> 같은 타입이지만 실행 결과가 다양한 객체를 이용(대입) 할 수 있는 성질을 말한다

- 하나의 타입에 여러개의 객체를 대입하여 다양한 기능 이용 가능

- 부모 타입에는 모든 자식 객체가 대입 가능

- 자식 타입은 부모 타입으로 자동 타입 변환 발생

  

- **자동 타입 변환(Promoted)**

  - 프로그램 실행중에 자동으로 타입변환이 일어나는 것

    

  - 바로 위의 부모가 아니더라도 상속 계층의 상위이면 자동 타입변환 가능

    - 비록 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정한다.

      

  - **주의**

    - 변환 후에는 부모 클래스 멤버만 가능

      

  - 자동 타입 변환 후에는 부모 클래스 멤버만 접근 가능

  - ```java
    Animal cat = new Cat(); // 자동 타입 변환
    //cat 변수는 Cat 객체를 참조하지만 Animal멤버만 접근이 가능하다.
    ```

  - 예외의 경우 : 오버라이딩

    - 메소드가 자식 클래스에 오버라이딩이 되었다면 자식 클래스의 메소드가 대신 호출된다.

  - 상속받은 경우

    - cat객체 Animal, Cat 멤버 접근 가능

    - ```java
      Animal c = new Cat();
      	// c는 Animal만 접근 가능
      	// 단, 오버라이딩 메소드는 Cat메소드 사용 가능
      ```

#### 정리

- 다형성

  - 동일한 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질
  - 코드 측면해서 보면 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있게 된다.
  - 자식 클래스에서 다양하게 메소드 오버라이딩 구현

- 강제 타입 변환(Casting)

  - 부모 타입을 자식 타입으로 변환하는 것

  - **주의!!**

    - 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 것은 아니다

    - 조건

      - 자식 타입을 부모 타입으로 자동 변환된 후, 다시 자식 타입으로 변환할 때만 가능하다.(원위치의 개념)

        

  - **강제 타입 변환이 필요한 경우**

    - 자식 타입이 부모 타입으로 자동 변환되면 부모 타입에 선언된 필드와 메소드만 사용 가능(오버라이딩 예외)

    - **자식 타입에 선언된 필드와 메소드를 다시 사용해야 할 경우**

#### 2. 객체 배열

> 객체를 가리키기 위한 레퍼런스 배열을 의미한다.

- 객체를 가리키는 레퍼런스를 원소로 가지는 배열

- ```java
  Person[] p = new Person[5];  //레퍼런스(참조변수) 5개 생성
  ```

  

- ```java
  p[i] = new Person();     //객체 생성
  ```

  - 객체가 생성되고 레퍼런스 배열의 각 원소가 객체를 가리킴

    => p : 레퍼런스 배열을 가리키는 참조 변수

    =>p[i] : **객체를 가리키는 참조 변수**

- **instanceof 연산자 : 객체 타입 확인**

  - 참조 변수가 참조하고 있는 인스턴스의 실제 타입 확인
  - 부모 타입이면 모두 자식 타입으로 강제 타입 변환할 수 있는 것 아님.
  - 부모 타입으로 변환되어 있는 상태에서만 강제 타입 변환 가능
  - 아니면 ClassCastException예외 발생
  - 먼저 자식 타입인지 확인 후 강제 타입 실행해야 함
    - instance of 연산자
  - boolean result = **참조변수** **instance of** 타입**(클래스명)**
    - 왼쪽의 참조변수가 오른쪽 타입의 인스턴스이면 true 봔환
    - true 반환되면 참조변수가 검사한 타입으로 타입 변환 가능

- **매개변수의 다형성**

  - 매개변수가 **클래스 타입일 경우**
  - **매개값을 다양화하기 위해 매개변수에 자식 타입 객체 대입 허용(자동 타입 변환)**
  - 따라서, 해당 객체뿐 아니라 자식 객체 까지도 매개값으로 사용 가능
  - 매개 값으로 어떤 객체가 전달되느냐에 따라 실행 결과가 달라짐→ 매개변수의 다형성
    - 자식 객체가 부모의 메소드를 재정의 했다면 내부에서 **오버라이딩된 메소드를 호출함으로써 실행결과 다양해짐**

- **추상 클래스(Abstract)**

  - **body가 구현되지 않은 미완성 메소드를 포함**하고 있다는 의미
  - 구체적인 내용은 구현하지 않고 **전체적인 틀만** 갖춘 상황
  - **상속 받는 클래스에서 용도에 맞게 구체적으로 구현해서 완성**
  - 추상 메소드를 포함하고 있다는 것을 제외하고는 일반 클래스와 동일

  - **추상화(abstract) 하는 것**

    - 실체들 간에 공통되는 특성을 추출하는 것
      - 예1> 새, 곤충, 물고기 → 동물(추상)
      - 예2> 삼성, 현대, LG → 회사(추상)

  - **추상 클래스 생성 방법**

    - **실체 클래스들의 공통되는 필드와 메소드를 정의**

      - **공통되는 규격을 정해 놓는 것**으로 **상속 받는 클래스에서 반드시 규격대로 구현**하라는 것
      - 규격 외 부분은 각 클래스 특성에 맞춰 추가

    - 추상 클래스는 실체 클래스의 부모 클래스 역할

      - **주의!!!! - new 연산자를 사용해서 단독 객체 생성 불가**

      **⇒ 실체 클래스 : 객체를 만들어 사용할 수 있는 클래스**

  - **추상 클래스의 용도**

    - 실체 클래스의 공통된 필드와 메소드의 이름을 통일할 목적
      - 실체 클래스 설계자가 여러 사람인 경우
      - 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질 수 있음
    - 실체 클래스를 작성할 때 시간절약
      - 실체 클래스는 추가적인 필드와 메소드만 선언(정의)
    - 실체 클래스 설계 규격을 만들고자 할 때
      - 실체 클래스가 가져야 할 필드와 메소드를 추상 클래스에서 미리 정의
      - 실체 클래스는 추상 클래스를 무조건 상속 받아 작성해야 함

  - **추상 클래스 목적**

    - 서브 클래스에서 필요로 하는 **대부분의 기능을 구현**해 두고 서브 클래스가 상속받아 활용할 수 있도록 하되 서브 클래스에서 **반드시 구현해야 하는 기능만을 추상 메소드로 선언**하여 서브클래스에서 반드시 구현하도록 하는 것

  - **추상 클래스 선언**

    - 클래스 선언에 **abstract** 키워드 사용

    - new 연산자로 객체생성 불가하고 상속을 통해서 자식 클래스만 생성 가능

      - new 연산자로 생성하지 못하지만 자식 객체가 생성될 때 super()를 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 반드시 있어야 함

    - ```java
      public abstract class 클래스명{
      
      // 필드, 상수
      
      // 생성자
      
      // 메소드()
      
      }
      ```

  - **추상 메소드(abstract method)**

    - 선은은 되어있으나 body가 정의되어 있지 않은 메소드
    - abstract 키워드로 선언
    - public **abstract** String getName();
    - public **abstract** String setName();

  - **추상 메소드와 오버라이딩(재정의)**

    - **메소드 이름은 동일하지만 실행 내용이 실체 클래스마다 다른 경우 추상 메소드로 선언**
    - 예> 동물은 소리를 낸다. 그러나 실체 동물들의 소리는 제각기 다르다.
    - 구현방법
      - 추상 클래스에는 메소드의 **선언부만 작성(추상 메소드)** : **메소드의 body 없음**
      - **실체 클래스에서 메소드의 실행 내용 작성**

    !
